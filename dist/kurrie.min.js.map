{"version":3,"sources":["../src/kurrie.js"],"names":[],"mappings":"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","file":"kurrie.min.js","sourcesContent":["/**\n * A *highly* optimized currying library focused on performance.\n * Support for partial applications and placeholders.\n * Supported by node and browsers (at least IE11+).\n * @author Jason James Pollman <jasonjpollman@gmail.com>\n * @license ISC\n * @since 10/3/18\n * @file\n */\n\n/* eslint-disable no-array-constructor, prefer-rest-params, no-underscore-dangle, require-jsdoc */\n\n/**\n * The prefix to inject in front of pseudo symbols.\n * @type {string}\n */\nconst SYMBOL_PREFIX = '@@kurrie/';\n\n/**\n * \"Polyfilling\" symbol in the event it doesn't exist (IE 11).\n * @param {string} label The symbol's label.\n * @returns {string|Symbol} A string, if symbols are unavailable.\n */\nconst Sym = typeof Symbol !== 'function'\n  /* istanbul ignore next: Symbol is always available in test env */\n  ? (label => SYMBOL_PREFIX.concat(label))\n  : Symbol;\n\n/**\n * Used to map curried functions back to their original source function.\n * @type {Sym}\n */\nconst SOURCE_FUNCTION = Sym('SOURCE_FUNCTION');\n\n/**\n * A default placeholder value.\n * Used for partial application to curried functions.\n * @type {Sym}\n */\nexport const _ = Sym('KURRIE_PLACEHOLDER');\n\n/**\n * An alternative placeholder value.\n * @type {Sym}\n */\nexport const __ = _;\n\n/**\n * Determines is the given function has been curried using kurrie.\n * @param {function} fn The function to inspect.\n * @returns {Boolean} True if `fn` is a curried function, false otherwise.\n */\nexport function isCurried(fn) {\n  return !!(fn && fn[SOURCE_FUNCTION]);\n}\n\n/**\n * Returns a curried function's source (original, uncurried) function.\n * @param {function} fn The function to get the source function of.\n * @returns {function|undefined} The function's source function.\n */\nexport function getSourceFunction(fn) {\n  return fn ? fn[SOURCE_FUNCTION] : undefined;\n}\n\n// Alias for getSourceFunction\nexport const uncurry = getSourceFunction;\n\n/**\n * The `toString` implementation for curried functions.\n * This will print thehe original function's source string\n * prepended with a friendly message that the function is curried.\n * @returns {string} The source function's code with a comment\n * informing the user that the function is curried.\n */\nfunction toStringForCurried() {\n  return '/* Wrapped with kurrie */\\r\\n'.concat(this[SOURCE_FUNCTION].toString());\n}\n\n/**\n * Gets the next argument set in the curry sequence. This will\n * combine the previous and current argument set, while replacing\n * placeholders in the previous set with the current. While similar\n * to `getArgumentsCapped`, they've been seperated for performance reasons.\n * @param {Array|Arguments} prev The previous function invocation's arguments.\n * @param {Arguments} curr The current function invocation's arguments.\n * @returns {Array} The \"concatenated\" arguments.\n */\nfunction getArgumentsUncapped(prev, curr) {\n  const args = new Array();\n\n  let i = 0;\n  let index = 0;\n\n  for (; i < prev.length; i++) {\n    args[i] = prev[i] === _ && index < curr.length ? curr[index++] : prev[i];\n  }\n\n  while (index < curr.length) {\n    args[i++] = curr[index++];\n  }\n\n  return args;\n}\n\n/**\n * Gets the next argument set in the curry sequence. This will\n * combine the previous and current argument set, while replacing\n * placeholders in the previous set with the current. This is the\n * capped version, which limits arguments to the function arity,\n * therefore \"properly\" disallowing rest and default params.\n * While similar to `getArgumentsUncapped`, they've been seperated\n * for performance reasons.\n * @param {Array|Arguments} prev The previous invocation's arguments.\n * @param {Arguments} curr The current invocation's arguments.\n * @param {number} arity The arity of the source function (`fn`).\n * @returns {Array} The \"concatenated\" arguments.\n */\nfunction getArgumentsCapped(prev, curr, arity) {\n  const args = new Array();\n\n  let i = 0;\n  let index = 0;\n\n  for (; i < arity && i < prev.length; i++) {\n    args[i] = prev[i] === _ && index < curr.length ? curr[index++] : prev[i];\n  }\n\n  while (i < arity && index < curr.length) {\n    args[i++] = curr[index++];\n  }\n\n  return args;\n}\n\n/**\n * Creates a new array from the given arguments set\n * with the number of items limited to `arity`.\n * @param {Arguments} args The argument set to cap.\n * @param {number} arity The arity of the source function.\n * @returns {Array} The capped arguments set.\n */\nfunction cap(args, arity) {\n  const capped = new Array();\n  for (let i = 0; i < arity; i++) capped[i] = args[i];\n  return capped;\n}\n\n/**\n * Determines if an argument set has any placeholders (up to arity), which\n * indicates that it's not safe to invoke the curried function's source function.\n * @param {Array|Arguments} args The argument set to inspect.\n * @param {number} arity The arity of the source function.\n * @returns {boolean} True if it's safe to call the source functon, false otherwise.\n */\nfunction hasPlaceholders(args, arity) {\n  for (let i = 0; i < arity; i++) if (args[i] === _) return true;\n  return false;\n}\n\n/**\n * Creates a curried version of `fn`.\n * @param {function} fn The source (original) function that's being curried.\n * @param {number} arity The arity of the source function to curry to. Once\n * arity has been achived by passing enough arguments, `fn` will be invoked.\n * @param {boolean} capped True if the number of arguments applied to `fn`\n * can exceed the arity. If false, rest params and default params won't work\n * without specifying a custom arity in the `curry` method below.\n * @returns {function} The curried function.\n */\nfunction create(fn, arity, capped) {\n  const getArguments = capped ? getArgumentsCapped : getArgumentsUncapped;\n\n  // Called after the first invocation.\n  // Previous arguments must be shallow copied\n  // and combined with the current argument set.\n  function recurry(previousArgs) {\n    function recurried() {\n      if (!arguments.length) return recurried;\n      const args = getArguments(previousArgs, arguments, arity);\n\n      return args.length < arity || hasPlaceholders(args, arity)\n        ? recurry(args)\n        : fn.apply(this, args);\n    }\n\n    recurried[SOURCE_FUNCTION] = fn;\n    recurried.toString = toStringForCurried;\n    return recurried;\n  }\n\n  // Optimized first invocation.\n  // Don't have to combine any arguments, since no prior calls have been made.\n  function curried() {\n    const size = arguments.length;\n    if (!size) return curried;\n\n    return size < arity || hasPlaceholders(arguments, arity)\n      ? recurry(arguments)\n      : fn.apply(this, capped && size > arity ? cap(arguments, arity) : arguments);\n  }\n\n  curried[SOURCE_FUNCTION] = fn;\n  curried.toString = toStringForCurried;\n  return curried;\n}\n\n/**\n * Curries a function.\n * @param {function} fn The function to curry.\n * @param {Object=} options Currying behavioral options.\n * @param {number} [options.arity=fn.length] The arity of `fn` or\n * a specific arity override to curry `fn` to.\n * @param {number} [options.capped=true] True to limit the number\n * of arguments to the source function to arity. If false, calling\n * `fn` with arguments > arity will pass them through.\n * @returns {function} The curried version of `fn`.\n * @export\n * @example\n * const curried = curry((x, y, z) => x + y + z);\n * curried()        // => curried\n * curried(1)       // => [object Function]\n * curried(1)(2)    // => [object Function]\n * curried(1)(2)(3) // => 6\n * curried(1, 2)(3) // => 6\n * curried(1)(2, 3) // => 6\n * curried(1, 2, 3) // => 6\n *\n * // You can also use partial application (placeholders)...\n * const triples = curry((a, b, c) => [a, b, c]);\n * triples(_, 2, 3)(1)    // => [1, 2, 3]\n * triples(_, _, 3)(1)(2) // => [1, 2, 3]\n * triples(1)(_)(2)(_)(3) // => [1, 2, 3]\n * triples(1)(_, 3)(2)    // => [1, 2, 3]\n * triples(_, 2)(1)(3)    // => [1, 2, 3]\n */\nexport default function curry(fn, { arity = fn.length, capped = true } = {}) {\n  if (typeof fn !== 'function') {\n    throw new Error('Expected a function for parameter `fn`');\n  }\n\n  // Don't curry a curried function or nullary functions.\n  return fn[SOURCE_FUNCTION] || arity <= 0 ? fn : create(fn, arity, capped);\n}\n\n/**\n * A variant of `curry` with the `fn` and `arity` arguments swapped.\n * In this variant, arity must be specified.\n * @param {number} arity The arity of `fn` or a specific arity override to curry `fn` to.\n * @param {function} fn The function to curry.\n * @param {boolean=} capped The value to pass to curry's `options.capped`.\n * @returns {function} The curried function.\n * @export\n */\nexport function curryTo(arity, fn, capped = true) {\n  return curry(fn, { arity, capped });\n}\n\n/**\n * Used to curry prototype methods.\n * This will wrap the given prototype method to use Function.apply,\n * providing the *last* argument provided as the `this` value for the call.\n *\n * See the example below for insight. If called on a regular function,\n * this could produce some interesting (unexpected) results.\n * @param {function} fn The prototype method to curry.\n * @param {number} [options.arity=fn.length] The arity of `fn` or\n * a specific arity override to curry `fn` to.\n * @param {number} [options.capped=true] True to limit the number\n * of arguments to the source function to arity. If false, calling\n * `fn` with arguments > arity will pass them through.\n * @param {number=} options.thisArgPosition The position of the argument to use\n * as the `this` argument when invoking the prototype method (as an override).\n * @returns {function} The curried method.\n * @example\n * // Convert Array#map to a curried method.\n * const map = curry.proto(Array.prototype.map);\n * map (x => x * 2) ([1, 2, 3]); // => [2, 4, 6]\n *\n * // Convert Array#filter to a curried method.\n * const filter = curry.proto(Array.prototype.filter);\n * const isOdd = filter(x => x % 2)\n * isOdd([1, 2, 3]) => [1, 3]\n *\n * // Convert String#toUpperCase to a curried method.\n * const toUpperCase = curry.proto(String.prototype.toUpperCase);\n * toUpperCase('foobar') // => 'FOOBAR'\n *\n * // Convert String#slice to a curried method\n * const slice = curry.proto(String.prototype.slice);\n * slice(0)(3)('foobar') // => 'foo'\n *\n * // Setting the arity to 2 to omit the end argument.\n * const sliceS = curry.proto(String.prototype.slice, { arity: 2 });\n * sliceS(3)('foobar') // => 'bar'\n * @export\n */\nexport function curryProto(fn, {\n  arity = fn.length + 1,\n  capped = true,\n  thisArgPosition = arity - 1,\n} = {}) {\n  function wrapper() {\n    const args = new Array();\n\n    for (let i = 0, n = 0; i < arguments.length; i++) {\n      if (i !== thisArgPosition) args[n++] = arguments[i];\n    }\n\n    return fn.apply(arguments[thisArgPosition], args);\n  }\n\n  wrapper.toString = fn.toString.bind(fn);\n  return curry(wrapper, { arity, capped });\n}\n\ncurry._ = _;\ncurry.__ = _;\ncurry.to = curryTo;\ncurry.proto = curryProto;\n"]}
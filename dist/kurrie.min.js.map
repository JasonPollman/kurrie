{"version":3,"sources":["../src/kurrie.js"],"names":[],"mappings":"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","file":"kurrie.min.js","sourcesContent":["/**\n * A highly optimized currying library focused on performance.\n * Support for partial applications and placeholders.\n * Supported by node and browsers (at least IE11+).\n * @author Jason James Pollman <jasonjpollman@gmail.com>\n * @license ISC\n * @since 10/3/18\n * @file\n */\n\n/* eslint-disable no-array-constructor, prefer-rest-params, no-underscore-dangle, require-jsdoc */\n\n/**\n * The prefix to inject in front of pseudo symbols.\n * @type {string}\n */\nconst SYMBOL_PREFIX = '@@kurrie/';\n\n/**\n * \"Polyfilling\" symbol in the event it doesn't exist (IE 11).\n * @param {string} label The symbol's label.\n * @returns {string|Symbol} A string, if symbols are unavailable.\n */\nconst Sym = typeof Symbol === 'function' ? Symbol : (label => SYMBOL_PREFIX.concat(label));\n\n/**\n * Used to map curried functions back to their original source function.\n * @type {Sym}\n */\nconst SOURCE_FUNCTION = Sym('SOURCE_FUNCTION');\n\n/**\n * A default placeholder value.\n * Used for partial application to curried functions.\n * @type {Sym}\n */\nexport const _ = Sym('KURRIE_PLACEHOLDER');\n\n/**\n * An alternative placeholder value.\n * @type {Sym}\n */\nexport const __ = _;\n\n/**\n * Determines is the given function has been curried using kurrie.\n * @param {function} fn The function to inspect.\n * @returns {Boolean} True if `fn` is a curried function, false otherwise.\n */\nexport function isCurried(fn) {\n  return !!(fn && fn[SOURCE_FUNCTION]);\n}\n\n/**\n * Returns a curried function's source (original, uncurried) function.\n * @param {function} fn The function to get the source function of.\n * @returns {function|undefined} The function's source function.\n */\nexport function getSourceFunction(fn) {\n  return fn ? fn[SOURCE_FUNCTION] : undefined;\n}\n\n/**\n * The `toString` implementation for curried functions.\n * @returns {string} The source function's code with a comment\n * informing the user that the function is curried.\n */\nfunction toStringForCurried() {\n  return '/* Wrapped with kurrie */\\n'.concat(this[SOURCE_FUNCTION].toString());\n}\n\n/**\n * Combines the previous invocation's arguments and the current invocation's.\n * This also replaces placeholders in the previous invocation's arguments with\n * current invocation values.\n * @param {Arguments} prev The previous invocation's arguments.\n * @param {Arguments} curr The current invokcation's arguments.\n * @param {number} arity The arity of the source function (`fn`).\n * @returns {Array} The \"concatenated\" arguments.\n */\nfunction concat(prev, curr) {\n  const args = new Array();\n\n  let i = 0;\n  let index = 0;\n\n  // Copy all previous arguments to the next arguments set.\n  // Also, if the previous argument is a placeholder, replace\n  // it with the value from the current argument set.\n  for (; i < prev.length; i++) {\n    args[i] = prev[i] === _ && index < curr.length ? curr[index++] : prev[i];\n  }\n\n  // Copy remaining arguments from the current argument set\n  // onto the next argument set, starting from where we stopped\n  // pulling placeholders from.\n  while (index < curr.length) {\n    args[i++] = curr[index++];\n  }\n\n  return args;\n}\n\n/**\n * \"Recurries\" a curried function (called by `curried` below).\n * @param {function} curried The `curried` function from below.\n * @param {Arguments} args The previous invocation's argument set.\n * @param {number} arity The arity of the source function (`fn`).\n * @returns {function} The recurried function.\n */\nfunction recurry(curried, args) {\n  return function recurried() {\n    return arguments.length ? curried.apply(this, concat(args, arguments)) : recurried;\n  };\n}\n\n/**\n * Determines if an argument set has no placeholders (up to arity), which\n * indicates that it's safe to invoke the curried function's source function.\n * @param {Arguments} args The argument set to inspect.\n * @param {number} arity The arity of the source function.\n * @returns {boolean} True if it's safe to call the source functon, false otherwise.\n */\nfunction hasFormalArguments(args, arity) {\n  for (let i = 0; i < arity; i++) {\n    if (args[i] === _) return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a curried version of `fn`.\n * @param {function} fn The source (original) function that's been curried.\n * @param {number} arity The arity of the source function.\n * been accumulated at this point in invocation.\n * @returns {function} The curried function.\n */\nfunction create(fn, arity) {\n  function curried() {\n    const size = arguments.length;\n\n    if (size >= arity && hasFormalArguments(arguments, arity)) {\n      return fn.apply(this, arguments);\n    }\n\n    if (size) {\n      const recurried = recurry(curried, arguments);\n      recurried[SOURCE_FUNCTION] = curried;\n      recurried.toString = toStringForCurried;\n      return recurried;\n    }\n\n    return curried;\n  }\n\n  curried[SOURCE_FUNCTION] = fn;\n  curried.toString = toStringForCurried;\n  return curried;\n}\n\n/**\n * Curries a function.\n * @param {function} fn The function to curry.\n * @param {number} [arity=fn.length] The arity of `fn` or\n * a specific arity override to curry `fn` to.\n * @returns {function} The curried version of `fn`.\n * @export\n * @example\n * const curried = curry((x, y, z) => x + y + z);\n * curried()        // => curried\n * curried(1)       // => [object Function]\n * curried(1)(2)    // => [object Function]\n * curried(1)(2)(3) // => 6\n * curried(1, 2)(3) // => 6\n * curried(1)(2, 3) // => 6\n * curried(1, 2, 3) // => 6\n *\n * // You can also use partial application (placeholders)...\n * const triples = curry((a, b, c) => [a, b, c]);\n * triples(_, 2, 3)(1)    // => [1, 2, 3]\n * triples(_, _, 3)(1)(2) // => [1, 2, 3]\n * triples(1)(_)(2)(_)(3) // => [1, 2, 3]\n * triples(1)(_, 3)(2)    // => [1, 2, 3]\n * triples(_, 2)(1)(3)    // => [1, 2, 3]\n */\nexport default function curry(fn, arity = fn.length) {\n  if (typeof fn !== 'function') {\n    throw new Error('Expected a function for parameter `fn`');\n  }\n\n  if (fn[SOURCE_FUNCTION] || arity === 0) return fn;\n  if (arity > 0) return create(fn, arity);\n\n  throw new Error(`Invalid arity value: ${arity}`);\n}\n\n/**\n * A variant of `curry` with the `fn` and `arity` arguments swapped.\n * In this variant, arity must be specified.\n * @param {number} arity The arity of `fn` or a specific arity override to curry `fn` to.\n * @param {function} fn The function to curry.\n * @returns {function} The curried function.\n * @export\n */\nexport function curryTo(arity, fn) {\n  return curry(fn, arity);\n}\n\n/**\n * Used to curry prototype methods.\n * This will wrap the given prototype method to use Function.call,\n * providing the *last* argument provided as the `this` value for the call.\n *\n * See the example below for insight. If called on a regular function,\n * this could produce some interesting (unexpected) results.\n * @param {function} fn The prototype method to curry.\n * @param {number=} arity The arity of `fn` or\n * a specific arity override to curry `fn` to.\n * @param {number=} thisArgPosition The position of the argument to use\n * as the `this` argument when invoking the prototype method (as an override).\n * @returns {function} The curried method.\n * @example\n * // Convert Array#map to a curried method.\n * const map = curry.proto(Array.prototype.map);\n * map (x => x * 2) ([1, 2, 3]); // => [2, 4, 6]\n *\n * // Convert Array#filter to a curried method.\n * const filter = curry.proto(Array.prototype.filter);\n * const isOdd = filter(x => x % 2)\n * isOdd([1, 2, 3]) => [1, 3]\n *\n * // Convert String#toUpperCase to a curried method.\n * const toUpperCase = curry.proto(String.prototype.toUpperCase);\n * toUpperCase('foobar') // => 'FOOBAR'\n *\n * // Convert String#slice to a curried method\n * const slice = curry.proto(String.prototype.slice);\n * slice(0)(3)('foobar') // => 'foo'\n *\n * // Setting the arity to 2 to omit the end argument.\n * const sliceS = curry.proto(String.prototype.slice, 2);\n * sliceS(3)('foobar') // => 'bar'\n * @export\n */\nexport function curryProto(fn, arity = fn.length + 1, thisArgPosition = arity - 1) {\n  function wrapper() {\n    const size = arguments.length;\n    const applied = new Array();\n\n    for (let i = 0, n = 0; i < size; i++) {\n      if (i !== thisArgPosition) applied[n++] = arguments[i];\n    }\n\n    return fn.apply(arguments[thisArgPosition], applied);\n  }\n\n  wrapper.toString = fn.toString.bind(fn);\n  return curry(wrapper, arity);\n}\n\ncurry._ = _;\ncurry.__ = _;\ncurry.to = curryTo;\ncurry.proto = curryProto;\n"]}